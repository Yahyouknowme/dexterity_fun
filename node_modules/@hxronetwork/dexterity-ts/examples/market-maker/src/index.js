// THIS SCRIPT IS AN EXAMPLE
// YOU COULD LOSE ALL YOUR MONEY AND MORE USING THIS SCRIPT OR ANY PART OF IT
// TRADE AT YOUR OWN RISK!

import { clusterApiUrl, Connection, Keypair, PublicKey } from "@solana/web3.js";
import { Wallet } from "@project-serum/anchor";
import {
  PriceStatus,
  PythConnection,
  getPythProgramKeyForCluster,
} from "@pythnetwork/client";
import dexterityTs from "@hxronetwork/dexterity-ts";
const dexterity = dexterityTs.default;

const CLUSTER_NAME = "devnet";
const rpc = clusterApiUrl(CLUSTER_NAME);

const keypair = Keypair.fromSecretKey(
  Uint8Array.from([
    67, 75, 229, 51, 51, 133, 126, 106, 32, 214, 75, 239, 177, 154, 192, 29,
    223, 170, 99, 41, 185, 175, 148, 30, 120, 141, 26, 213, 41, 152, 35, 141,
    97, 53, 137, 5, 206, 35, 136, 98, 82, 83, 72, 173, 169, 94, 125, 174, 217,
    112, 123, 130, 71, 141, 203, 116, 239, 178, 255, 216, 93, 25, 242, 22,
  ])
);
const wallet = new Wallet(keypair);

// New dexterity wallet object
const UserWallet = {
  publicKey: wallet.PublicKey,
  signTransaction: wallet.signTransaction,
  signAllTransactions: wallet.signAllTransactions,
};

const connection = new Connection(rpc, "processed");
const airdropSignature = await connection.requestAirdrop(
  wallet.publicKey,
  1000000000 // 1 SOL = 1 billion Lamports
);
await connection.confirmTransaction(airdropSignature);

// get the latest manifest
const manifest = await dexterity.getManifest(rpc, false, UserWallet);

const mpgPubkey = new PublicKey("HyWxreWnng9ZBDPYpuYugAfpCMkRkJ1oz93oyoybDFLB");
const trgPubkey = new PublicKey("ZaPr4yhfCRkM1wJ1hp2g4Ufvk1uUwrYgDPGcVhMcgHY");

console.log(
  `Wallet: ${wallet.publicKey.toBase58()} TRG: ${trgPubkey.toBase58()}`
);

// create a trader
const trader = new dexterity.Trader(manifest, trgPubkey);

// define what happens when our trader changes in any way
const onUpdate = () => {
  console.log(
    "Portfolio Value:",
    trader.getPortfolioValue().toString(),
    "Position Value:",
    trader.getPositionValue().toString(),
    "Net Cash:",
    trader.getNetCash().toString(),
    "PnL:",
    trader.getPnL().toString()
  );
};

// call connect() so updates are streamed
await trader.connect(onUpdate);

// deposit 100k UXDC
// ask for UXDC in discord if you're trading on devnet
console.log("depositing 100,000 UXDC...");
await trader.deposit(dexterity.Fractional.New(100000, 0));

// find the PERP
const PRODUCT_NAME = "BTCUSD-PERP     ";
let perpIndex;
for (const [name, { index, product }] of trader.getProducts()) {
  console.log("saw", name);
  if (name !== PRODUCT_NAME) {
    continue;
  }
  perpIndex = index;
  break;
}

// Define the constant parameters of our market making algorithm:
//     +- 10 basis points
const QUOTE_SIZE = dexterity.Fractional.New(1, 0); // 1.0000 contracts
const QUOTE_RADIUS_PROPORTION = dexterity.Fractional.New(10, 4);
const QUOTE_BID_FACTOR = dexterity.Fractional.New(1, 0).sub(
  QUOTE_RADIUS_PROPORTION
);
const QUOTE_ASK_FACTOR = dexterity.Fractional.New(1, 0).add(
  QUOTE_RADIUS_PROPORTION
);
const MINIMUM_QUOTE_DELTA_PROPORTION = dexterity.Fractional.New(5, 4); // move quote by minimum of 5 bps
let current_bid, current_ask;

// subscribe to the Pyth BTCUSD price oracle
const pythConnection = new PythConnection(
  manifest.fields.connection,
  getPythProgramKeyForCluster(CLUSTER_NAME)
);
pythConnection.onPriceChange(async (product, price) => {
  if (product.symbol !== "Crypto.BTC/USD") {
    return;
  }
  if (price.status !== 1) {
    console.log(
      `cancelling all orders and not quoting because status is not trading; status: ${price.status}`
    );
    await trader.cancelAllOrders([PRODUCT_NAME]);
    return;
  }
  const dollars = dexterity.Fractional.New(parseInt(price.price.toString()), 0);
  const bid = dollars.mul(QUOTE_BID_FACTOR);
  const ask = dollars.mul(QUOTE_ASK_FACTOR);
  const min_delta = dollars.mul(MINIMUM_QUOTE_DELTA_PROPORTION);
  if (
    !current_bid ||
    current_bid.sub(bid).abs().gt(min_delta) ||
    !current_ask ||
    current_ask.sub(ask).abs().gt(min_delta)
  ) {
    console.log("moving quotes");
    await trader.cancelAllOrders([PRODUCT_NAME]);
    trader.newOrder(perpIndex, true, bid, QUOTE_SIZE);
    trader.newOrder(perpIndex, false, ask, QUOTE_SIZE);
    current_bid = bid;
    current_ask = ask;
  }
  console.log(
    `price: ${
      price.price
    }; quoting at ${current_bid.toString()} and ${current_ask.toString()}`
  );
});

// Start listening for price change events.
pythConnection.start();
