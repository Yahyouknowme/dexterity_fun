import BN from "bn.js";
import { Program, web3, Wallet } from "@project-serum/anchor";
import { Connection, PublicKey, Transaction, VersionedTransaction } from "@solana/web3.js";
import { MarketState, LeafNode } from "@bonfida/aaob";
export type DexterityWallet = {
    publicKey: PublicKey;
    signTransaction: <T extends Transaction | VersionedTransaction>(transaction: T) => Promise<T>;
    signAllTransactions: <T extends Transaction | VersionedTransaction>(transactions: T[]) => Promise<T[]>;
};
interface Product {
}
interface MarketProductGroup {
    feeModelProgramId: PublicKey;
    feeModelConfigurationAcct: PublicKey;
    feeOutputRegister: PublicKey;
    riskEngineProgramId: PublicKey;
    riskModelConfigurationAcct: PublicKey;
    riskOutputRegister: PublicKey;
    vaultMint: PublicKey;
    marketProducts: {
        array: Array<Product>;
    };
}
interface TraderRiskGroup {
    feeStateAccount: PublicKey;
    marketProductGroup: PublicKey;
    owner: PublicKey;
    riskStateAccount: PublicKey;
    openOrders: {
        products: Array<{
            headIndex: BN;
        }>;
        orders: Array<{
            id: BN;
            qty: BN;
            next: BN;
            prev: BN;
        }>;
    };
    traderPositions: Array<{
        tag: Object;
        productIndex: number;
        productKey: PublicKey;
        position: SimpleFractional;
    }>;
    cashBalance: SimpleFractional;
    pendingCashBalance: SimpleFractional;
    totalWithdrawn: SimpleFractional;
    totalDeposited: SimpleFractional;
}
interface I128 {
    value: BN;
}
interface MarkPrice {
    productKey: PublicKey;
    markPrice: I128;
    prevOracleMinusBookEwma: I128;
    oracleMinusBookEwma: I128;
}
interface MarkPricesArray {
    isHardcodedOracle: boolean;
    hardcodedOracle: PublicKey;
    array: Array<MarkPrice>;
}
interface DerivativeMetadata {
    priceOracle: PublicKey;
}
type SimpleFractional = {
    m: BN;
    exp: BN;
};
declare class ReliableWebSocket {
    socket: WebSocket;
    isClosed: boolean;
    ref: number;
    eventQueueSeqNum: number;
    constructor(socket: WebSocket);
    close(): void;
    addRef(): this;
}
type ManifestFields = {
    rpc: string;
    wallet: DexterityWallet | Wallet;
    connection: Connection;
    dexProgram: Program;
    instrumentsProgram: Program;
    riskProgram: Program;
    aaob_id: PublicKey;
    dex_id: PublicKey;
    fees_id: PublicKey;
    risk_id: PublicKey;
    mpgs: Map<string, {
        pubkey: PublicKey;
        mpg: MarketProductGroup;
        orderbooks: Map<string, MarketState>;
        covarianceMetadata: CovarianceMetadata;
    }>;
    creationTime: number;
};
declare class Order {
    id: BN;
    productName: string;
    productIndex: number;
    price: Fractional;
    qty: Fractional;
    isBid: boolean;
    constructor(id: BN, productName: string, productIndex: number, price: Fractional, qty: Fractional, isBid: boolean);
}
type ApiFill = {
    tx_sig: string;
    product: string;
    block_timestamp: Date;
    slot: number;
    inserted_at: Date;
    taker_side: string;
    maker_order_id: number;
    quote_size: number;
    base_size: number;
    maker_trg: string;
    taker_trg: string;
};
type GetFillsResponse = {
    fills: ApiFill[];
};
declare class Manifest {
    fields: ManifestFields;
    base_api_url: string;
    slot: number;
    timestamp: Date;
    constructor(fields: ManifestFields);
    setWallet(wallet: any): void;
    static GetRiskAndFeeSigner(mpg: PublicKey): PublicKey;
    getRiskS(mpg: PublicKey): PublicKey;
    getRiskR(mpg: PublicKey): PublicKey;
    static GetATAFromMPGObject(mpg: MarketProductGroup, wallet: PublicKey): Promise<web3.PublicKey>;
    accountSubscribe(pk: any, parseDataFn: any, onUpdateFn: any, useCache?: boolean): any;
    static GetMarkPrice(markPrices: MarkPricesArray, productKey: PublicKey): Fractional;
    static GetMarkPriceOracleMinusBookEwma(markPrices: MarkPricesArray, productKey: PublicKey): Fractional;
    static FromFastInt(bn: BN): Fractional;
    getMPGFromData(data: any): Promise<MarketProductGroup>;
    static GetMPGFromData(dexProgram: Program, data: any): Promise<MarketProductGroup>;
    getMPG(mpg: PublicKey): Promise<MarketProductGroup>;
    static GetProductsOfMPG(mpg: MarketProductGroup): Map<any, any>;
    static GetActiveProductsOfMPG(mpg: MarketProductGroup): Map<any, any>;
    getDerivativeMetadataFromData(data: any): Promise<DerivativeMetadata>;
    static GetDerivativeMetadataFromData(instrumentsProgram: Program, data: any): Promise<DerivativeMetadata>;
    getDerivativeMetadata(productKey: PublicKey): Promise<DerivativeMetadata>;
    getTRGFromData(data: any): Promise<TraderRiskGroup>;
    getTRG(trg: PublicKey): Promise<TraderRiskGroup>;
    getMarkPricesAccount(mpg: PublicKey): PublicKey;
    ugh(str: any): web3.PublicKey;
    getMarkPricesFromData(data: any): Promise<MarkPricesArray>;
    getMarkPrices(markPricesAccount: PublicKey): Promise<MarkPricesArray>;
    getVarianceCache(varianceCache: PublicKey): Promise<VarianceCache>;
    getCovarianceMetadata(marketProductGroup: PublicKey): Promise<CovarianceMetadata>;
    getBook(product: any, marketState: any): Promise<{
        bids: any[];
        asks: any[];
    }>;
    static aaobOrderToDexPrice(aaobOrder: LeafNode, tickSize: Fractional, offset: Fractional): Fractional;
    static orderIdToDexPrice(id: BN, tickSize: Fractional, offset: Fractional): Fractional;
    static orderIdIsBid(id: BN): boolean;
    streamBooks(product: any, marketState: any, onBookFn: any, onMarkPricesFn?: any): {
        asksSocket: ReliableWebSocket;
        bidsSocket: ReliableWebSocket;
        markPricesSocket: ReliableWebSocket;
    };
    streamTrades(product: any, marketState: any, onTradesFn: any): ReliableWebSocket;
    streamMPG(mpg: PublicKey, onUpdateFn: any): ReliableWebSocket;
    getTRGsOfOwner(owner: PublicKey, marketProductGroup?: PublicKey): Promise<any[]>;
    getTRGsOfWallet(marketProductGroup?: PublicKey): Promise<any[]>;
    closeTrg(marketProductGroup: PublicKey, traderRiskGroup: PublicKey): Promise<any>;
    createTrg(marketProductGroup: PublicKey): Promise<web3.PublicKey>;
    fetchOrderbooks(marketProductGroup?: PublicKey): Promise<void>;
    fetchOrderbook(orderbook: PublicKey): Promise<any>;
    getFills(productName: string, trg: PublicKey, before: number, after: number): Promise<string | GetFillsResponse>;
    updateOrderbooks(marketProductGroup: PublicKey): Promise<void>;
    updateCovarianceMetadatas(): Promise<void>;
    static GetRiskNumber(data: any, offset: any, size: any, isSigned?: boolean): any;
    getStds(marketProductGroup: PublicKey): Map<any, any>;
}
declare function getManifest(rpc: string, useCache: boolean, wallet: DexterityWallet | Wallet): Promise<Manifest>;
declare function bytesToString(bytes: any): any;
declare class Fractional {
    m: BN;
    exp: BN;
    _isNan: boolean;
    constructor(m: BN, exp: BN);
    static New(m: number, exp: number): Fractional;
    static From(simple: {
        m: BN;
        exp: BN;
    }): Fractional;
    static FromString(s: string): Fractional;
    static Zero(): Fractional;
    static One(): Fractional;
    static NegativeOne(): Fractional;
    static NoBidPrice(): Fractional;
    static NoAskPrice(): Fractional;
    static Nan(): Fractional;
    isNan(): boolean;
    isZero(): any;
    max(other: Fractional): Fractional;
    toNumber(): number;
    toDecimal(): number;
    scale(c: number): Fractional;
    scaledown(c: number): Fractional;
    add(other: Fractional): Fractional;
    round_up(newExp: BN): Fractional;
    round_down(newExp: BN): Fractional;
    sub(other: Fractional): Fractional;
    sign(): BN;
    sqrt(): BN;
    abs(): Fractional;
    div(other: Fractional): Fractional;
    mul(other: any): Fractional;
    reduced(): Fractional;
    cmp(other: Fractional): number;
    lt(other: Fractional): boolean;
    lte(other: Fractional): boolean;
    eq(other: Fractional): boolean;
    gt(other: Fractional): boolean;
    gte(other: Fractional): boolean;
    toString(fixedDecimals?: any, isInsertCommas?: boolean): string;
    _toString(fixedDecimals?: any): string;
}
declare function getPriceDecimals(meta: any): any;
declare function productStatus(p: any, productArray: any): any;
declare function productToMeta(p: any): any;
type VarianceCache = Uint8Array;
type CovarianceMetadata = Uint8Array;
enum TraderUpdateType {
    TRG = 0,
    MPG = 1,
    Risk = 2,
    MarkPrices = 3
}
type Slot = number;
declare class Trader {
    manifest: Manifest;
    feeAccount: PublicKey;
    feeAccountBump: number;
    marketProductGroup: PublicKey;
    traderRiskGroup: PublicKey;
    riskStateAccount: PublicKey;
    markPricesAccount: PublicKey;
    hardcodedOracle: PublicKey;
    priceOracles: Map<string, PublicKey>;
    mpg: MarketProductGroup;
    trg: TraderRiskGroup;
    varianceCache: VarianceCache;
    markPrices: MarkPricesArray;
    trgSocket: ReliableWebSocket;
    mpgSocket: ReliableWebSocket;
    riskSocket: ReliableWebSocket;
    markPricesSocket: ReliableWebSocket;
    trgDate: Date;
    mpgDate: Date;
    riskDate: Date;
    markPricesDate: Date;
    trgSlot: Slot;
    mpgSlot: Slot;
    riskSlot: Slot;
    markPricesSlot: Slot;
    isPaused: boolean;
    skipThingsThatRequireWalletConnection: boolean;
    constructor(manifest: Manifest, traderRiskGroup: PublicKey, skipThingsThatRequireWalletConnection?: boolean);
    timeTravelToDate(toDate: Date): Promise<void>;
    getProducts(): Map<any, any>;
    getPositions(): Map<any, any>;
    newOrder(productIndex: any, isBid: any, limitPrice: Fractional, maxBaseQty: Fractional, { onGettingBlockHashFn, onGotBlockHashFn, onTxSentFn, onTxSuccessFn, onFailFn }?: {
        onGettingBlockHashFn: any;
        onGotBlockHashFn: any;
        onTxSentFn: any;
        onTxSuccessFn: any;
        onFailFn: any;
    }, isIOC?: boolean, referrerTrg?: any, referrerFeeBps?: any, clientOrderId?: any, matchLimit?: any): Promise<void>;
    updateVarianceCache(): Promise<void>;
    getUpdateVarianceCacheInstruction(): Promise<web3.TransactionInstruction>;
    getUpdateMarkPricesInstruction(products: Array<Product>): web3.TransactionInstruction;
    initializePrintTrade(isBid: any, size: any, price: any, counterparty: PublicKey): Promise<void>;
    getOpenOrders(productNames: any): Set<Order>;
    getOpenOrderIds(productName: any): Set<string>;
    cancelAllOrders(productNames: any, isUseCache?: boolean): Promise<void>;
    batchCancelOrders(product: any, orderIds: any, { onGettingBlockHashFn, onGotBlockHashFn, onTxSentFn, onTxSuccessFn, onFailFn }?: {
        onGettingBlockHashFn: any;
        onGotBlockHashFn: any;
        onTxSentFn: any;
        onTxSuccessFn: any;
        onFailFn: any;
    }, clientOrderId?: any): Promise<any>;
    cancelOrders(productIndex: any, orderIds: any, isUseCache?: boolean, { onGettingBlockHashFn, onGotBlockHashFn, onTxSentFn, onTxSuccessFn, onFailFn }?: {
        onGettingBlockHashFn: any;
        onGotBlockHashFn: any;
        onTxSentFn: any;
        onTxSuccessFn: any;
        onFailFn: any;
    }, clientOrderId?: any): Promise<void>;
    deposit(usdcAmount: Fractional): Promise<void>;
    updateTraderRiskGroupOwner(newOwner: PublicKey, oldOwner?: PublicKey): Promise<void>;
    withdraw(usdcAmount: Fractional): Promise<void>;
    updateOrderbooks(): Promise<void>;
    disconnect(): void;
    streamUpdates(onUpdateFn: any): void;
    updateRisk(): Promise<void>;
    getRiskNumber(offset: any, size: any, isSigned?: boolean): any;
    getVarianceCacheUpdateSlot(): any;
    getPositionValue(): Fractional;
    getTradedVariance(): Fractional;
    getOpenOrderVariance(): Fractional;
    getCashBalance(): Fractional;
    getPendingCashBalance(): Fractional;
    getNetCash(): Fractional;
    getPortfolioValue(): Fractional;
    getTotalDeposited(): Fractional;
    getTotalWithdrawn(): Fractional;
    getDepositedCollateral(): Fractional;
    getPnL(): Fractional;
    getRequiredMaintenanceMargin(): any;
    getRequiredMaintenanceMarginWithoutOpenOrders(): any;
    getRequiredInitialMargin(): any;
    getRequiredInitialMarginWithoutOpenOrders(): any;
    getExcessMaintenanceMargin(): Fractional;
    getExcessInitialMargin(): Fractional;
    getExcessMaintenanceMarginWithoutOpenOrders(): Fractional;
    getExcessInitialMarginWithoutOpenOrders(): Fractional;
    updateMarkPrices(): Promise<void>;
    update(isUpdateMPG?: boolean): Promise<void>;
    connect(streamUpdatesCallback: any, initialUpdateCallback: any): Promise<void>;
}
declare const _default: {
    bytesToString: typeof bytesToString;
    Fractional: typeof Fractional;
    getManifest: typeof getManifest;
    getPriceDecimals: typeof getPriceDecimals;
    Manifest: typeof Manifest;
    productStatus: typeof productStatus;
    productToMeta: typeof productToMeta;
    rpc2manifest: Map<any, any>;
    Trader: typeof Trader;
    TraderUpdateType: typeof TraderUpdateType;
};
export default _default;

//# sourceMappingURL=types.d.ts.map
