"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventQueue = exports.EventOut = exports.EventFill = exports.EventQueueHeader = exports.Side = exports.EventType = void 0;
const borsh_1 = require("borsh");
const bn_js_1 = __importDefault(require("bn.js"));
/** @enum {number} */
var EventType;
(function (EventType) {
    EventType[EventType["Fill"] = 0] = "Fill";
    EventType[EventType["Out"] = 1] = "Out";
})(EventType = exports.EventType || (exports.EventType = {}));
/** @enum {number} */
var Side;
(function (Side) {
    Side[Side["Bid"] = 0] = "Bid";
    Side[Side["Ask"] = 1] = "Ask";
})(Side = exports.Side || (exports.Side = {}));
/**
 * Event queue header object
 */
class EventQueueHeader {
    constructor(arg) {
        this.tag = arg.tag;
        this.head = arg.head;
        this.count = arg.count;
        this.eventSize = arg.eventSize;
        this.seqNum = arg.seqNum;
    }
    /**
     * @param callBackInfoLen number of bytes in the callback info
     * @returns event queue slot size
     */
    static computeSlotSize(callBackInfoLen) {
        return callBackInfoLen.muln(2).addn(1 + 33);
    }
}
exports.EventQueueHeader = EventQueueHeader;
EventQueueHeader.LEN = 37;
EventQueueHeader.REGISTER_SIZE = 42;
EventQueueHeader.schema = new Map([
    [
        EventQueueHeader,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["head", "u64"],
                ["count", "u64"],
                ["eventSize", "u64"],
                ["seqNum", "u64"],
            ],
        },
    ],
]);
/**
 * Event fill object
 */
class EventFill {
    constructor(arg) {
        this.takerSide = arg.takerSide;
        this.makerOrderId = arg.makerOrderId;
        this.quoteSize = arg.quoteSize;
        this.baseSize = arg.baseSize;
        this.makerCallbackInfo = arg.makerCallbackInfo;
        this.takerCallbackInfo = arg.takerCallbackInfo;
    }
    /**
     * Deserialize a buffer into an EventFill object
     * @param callbackInfoLen Length of the callback information
     * @param data Buffer to deserialize
     * @returns Returns an EventFill object
     */
    static deserialize(callbackInfoLen, data) {
        return new EventFill({
            takerSide: data[1],
            makerOrderId: new bn_js_1.default(data.slice(2, 18), "le"),
            quoteSize: new bn_js_1.default(data.slice(18, 26), "le"),
            baseSize: new bn_js_1.default(data.slice(26, 34), "le"),
            makerCallbackInfo: [...data.slice(34, 34 + callbackInfoLen)],
            takerCallbackInfo: [
                ...data.slice(34 + callbackInfoLen, 34 + 2 * callbackInfoLen),
            ],
        });
    }
}
exports.EventFill = EventFill;
/**
 * EventOut object
 */
class EventOut {
    constructor(arg) {
        this.side = arg.side;
        this.orderId = arg.orderId;
        this.baseSize = arg.baseSize;
        this.delete = arg.delete === 1;
        this.callBackInfo = arg.callBackInfo;
    }
    /**
     * Deserialize a buffer into an EventOut object
     * @param callbackInfoLen Length of the callback information
     * @param data Buffer to deserialize
     * @returns Returns an EventOut object
     */
    static deserialize(callbackInfoLen, data) {
        return new EventOut({
            side: data[1],
            orderId: new bn_js_1.default(data.slice(2, 18), "le"),
            baseSize: new bn_js_1.default(data.slice(18, 26), "le"),
            delete: data[26],
            callBackInfo: [...data.slice(27, 27 + callbackInfoLen)],
        });
    }
}
exports.EventOut = EventOut;
/**
 * Event queue object
 */
class EventQueue {
    constructor(arg) {
        this.header = arg.header;
        this.buffer = arg.buffer;
        this.callBackInfoLen = arg.callBackInfoLen;
    }
    /**
     * Deserialize a buffer into an EventQueue object
     * @param callBackInfoLen Length of the callback information
     * @param data Buffer to deserialize
     * @returns Returns an EventQueue object
     */
    static parse(callBackInfoLen, data) {
        return new EventQueue({
            header: borsh_1.deserializeUnchecked(EventQueueHeader.schema, EventQueueHeader, data),
            buffer: [...data],
            callBackInfoLen,
        });
    }
    /**
     * Loads the event queue from its address
     * @param connection The solana connection object to the RPC node
     * @param address The address of the event queue
     * @param callBackInfoLen The length of the callback information
     * @returns Returns an EventQueue object
     */
    static async load(connection, address, callBackInfoLen) {
        const accountInfo = await connection.getAccountInfo(address);
        if (!(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data)) {
            throw new Error("Invalid address provided");
        }
        return this.parse(callBackInfoLen, accountInfo.data);
    }
    /**
     * Returns an event from its index in the event queue
     * @param idx Index of the event to parse
     * @returns Returns an Event object
     */
    parseEvent(idx) {
        let header_offset = EventQueueHeader.LEN + EventQueueHeader.REGISTER_SIZE;
        let offset = header_offset +
            ((idx * this.header.eventSize.toNumber() + this.header.head.toNumber()) %
                (this.buffer.length - header_offset));
        let data = Buffer.from(this.buffer.slice(offset, offset + this.header.eventSize.toNumber()));
        switch (data[0]) {
            case EventType.Fill:
                return EventFill.deserialize(this.callBackInfoLen, data);
            case EventType.Out:
                return EventOut.deserialize(this.callBackInfoLen, data);
            default:
                throw new Error("Invalid data provided");
        }
    }
    /**
     * Returns fill events from the event queue
     * @param limit Optional limit parameter
     * @returns An array of EventFill
     */
    parseFill(limit) {
        const n = limit
            ? Math.min(limit, this.header.count.toNumber())
            : this.header.count.toNumber();
        return [...Array(n).keys()]
            .map((e) => this.parseEvent(e))
            .filter((e) => e instanceof EventFill);
    }
    /**
     * Deserialize a buffer into an EventQueueHeader object
     * @param data Buffer to deserialize
     * @returns Returns an EventQueueHeader object
     */
    static parseEventQueueHeader(data) {
        return borsh_1.deserialize(EventQueueHeader.schema, EventQueueHeader, data);
    }
    /**
     * Extract the event queue registrar
     * @param data Buffer to extract the registrar from
     * @returns Returns the event queue registrar data as a buffer
     */
    extractRegister(data) {
        return data.slice(EventQueueHeader.LEN, EventQueueHeader.LEN + EventQueueHeader.REGISTER_SIZE);
    }
}
exports.EventQueue = EventQueue;
//# sourceMappingURL=event_queue.js.map