/// <reference types="node" />
import { Connection, PublicKey } from "@solana/web3.js";
import { Schema } from "borsh";
import BN from "bn.js";
import { AccountTag } from "./market_state";
/** @enum {number} */
export declare enum EventType {
    Fill = 0,
    Out = 1
}
/** @enum {number} */
export declare enum Side {
    Bid = 0,
    Ask = 1
}
/**
 * Event queue header object
 */
export declare class EventQueueHeader {
    tag: AccountTag;
    head: BN;
    count: BN;
    eventSize: BN;
    seqNum: BN;
    static LEN: number;
    static REGISTER_SIZE: number;
    /**
     * @param callBackInfoLen number of bytes in the callback info
     * @returns event queue slot size
     */
    static computeSlotSize(callBackInfoLen: BN): BN;
    static schema: Schema;
    constructor(arg: {
        tag: number;
        head: BN;
        count: BN;
        eventSize: BN;
        seqNum: BN;
    });
}
/**
 * Event fill object
 */
export declare class EventFill {
    takerSide: Side;
    makerOrderId: BN;
    quoteSize: BN;
    baseSize: BN;
    makerCallbackInfo: number[];
    takerCallbackInfo: number[];
    constructor(arg: {
        takerSide: number;
        makerOrderId: BN;
        quoteSize: BN;
        baseSize: BN;
        makerCallbackInfo: number[];
        takerCallbackInfo: number[];
    });
    /**
     * Deserialize a buffer into an EventFill object
     * @param callbackInfoLen Length of the callback information
     * @param data Buffer to deserialize
     * @returns Returns an EventFill object
     */
    static deserialize(callbackInfoLen: number, data: Buffer): EventFill;
}
/**
 * EventOut object
 */
export declare class EventOut {
    side: Side;
    orderId: BN;
    baseSize: BN;
    delete: boolean;
    callBackInfo: number[];
    constructor(arg: {
        side: number;
        orderId: BN;
        baseSize: BN;
        delete: number;
        callBackInfo: number[];
    });
    /**
     * Deserialize a buffer into an EventOut object
     * @param callbackInfoLen Length of the callback information
     * @param data Buffer to deserialize
     * @returns Returns an EventOut object
     */
    static deserialize(callbackInfoLen: number, data: Buffer): EventOut;
}
/**
 * Event queue object
 */
export declare class EventQueue {
    header: EventQueueHeader;
    buffer: number[];
    callBackInfoLen: number;
    constructor(arg: {
        header: EventQueueHeader;
        buffer: number[];
        callBackInfoLen: number;
    });
    /**
     * Deserialize a buffer into an EventQueue object
     * @param callBackInfoLen Length of the callback information
     * @param data Buffer to deserialize
     * @returns Returns an EventQueue object
     */
    static parse(callBackInfoLen: number, data: Buffer): EventQueue;
    /**
     * Loads the event queue from its address
     * @param connection The solana connection object to the RPC node
     * @param address The address of the event queue
     * @param callBackInfoLen The length of the callback information
     * @returns Returns an EventQueue object
     */
    static load(connection: Connection, address: PublicKey, callBackInfoLen: number): Promise<EventQueue>;
    /**
     * Returns an event from its index in the event queue
     * @param idx Index of the event to parse
     * @returns Returns an Event object
     */
    parseEvent(idx: number): EventFill | EventOut;
    /**
     * Returns fill events from the event queue
     * @param limit Optional limit parameter
     * @returns An array of EventFill
     */
    parseFill(limit?: number): (EventFill | EventOut)[];
    /**
     * Deserialize a buffer into an EventQueueHeader object
     * @param data Buffer to deserialize
     * @returns Returns an EventQueueHeader object
     */
    static parseEventQueueHeader(data: Buffer): EventQueueHeader;
    /**
     * Extract the event queue registrar
     * @param data Buffer to extract the registrar from
     * @returns Returns the event queue registrar data as a buffer
     */
    extractRegister(data: Buffer): Buffer;
}
