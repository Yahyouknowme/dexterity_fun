"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMarket = exports.AAOB_ID = void 0;
const web3_js_1 = require("@solana/web3.js");
const event_queue_1 = require("./event_queue");
const market_state_1 = require("./market_state");
const slab_1 = require("./slab");
const raw_instructions_1 = require("./raw_instructions");
// Devnet
exports.AAOB_ID = new web3_js_1.PublicKey("aaobKniTtDGvCZces7GH5UReLYP671bBkB96ahr9x3e");
/**
 *
 * @param connection The solana connection object to the RPC node
 * @param callerAuthority The caller authority will be the required signer for all market instructions.
 * Callback information can be used by the caller to attach specific information to all orders.
 * In practice, it will almost always be a program-derived address.
 * @param callbackInfoLen An example of this would be to store a public key to uniquely identify the owner of a particular order. This example would require a value of 32
 * @param callbackIdLen The prefix length of callback information which is used to identify self-trading in this example
 * @param eventCapacity The capacity of an event
 * @param nodesCapacity The capacity of a node
 * @param feePayer The fee payer of the transaction
 * @param programId The agnostic orderbook program ID, or null to use the deployed program ID
 * @returns
 */
const createMarket = async (connection, callerAuthority, callbackInfoLen, callbackIdLen, eventCapacity, nodesCapacity, minBaseOrderSize, feePayer, tickSize, crankerReward, programId) => {
    if (programId === undefined) {
        programId = exports.AAOB_ID;
    }
    let signers = [];
    let txInstructions = [];
    // Event queue account
    const eventQueue = new web3_js_1.Keypair();
    const eventQueueSize = event_queue_1.EventQueueHeader.LEN +
        event_queue_1.EventQueueHeader.REGISTER_SIZE +
        event_queue_1.EventQueueHeader.computeSlotSize(callbackInfoLen)
            .muln(eventCapacity)
            .toNumber();
    const createEventQueueAccount = web3_js_1.SystemProgram.createAccount({
        fromPubkey: feePayer,
        lamports: await connection.getMinimumBalanceForRentExemption(eventQueueSize),
        newAccountPubkey: eventQueue.publicKey,
        programId,
        space: eventQueueSize,
    });
    signers.push(eventQueue);
    txInstructions.push(createEventQueueAccount);
    // Bids account
    const bids = new web3_js_1.Keypair();
    const slabSize = slab_1.SlabHeader.PADDED_LEN + slab_1.Slab.SLOT_SIZE * nodesCapacity;
    const createBidsAccount = web3_js_1.SystemProgram.createAccount({
        fromPubkey: feePayer,
        lamports: await connection.getMinimumBalanceForRentExemption(slabSize),
        newAccountPubkey: bids.publicKey,
        programId,
        space: slabSize,
    });
    signers.push(bids);
    txInstructions.push(createBidsAccount);
    // Asks account
    const asks = new web3_js_1.Keypair();
    const createAsksAccount = web3_js_1.SystemProgram.createAccount({
        fromPubkey: feePayer,
        lamports: await connection.getMinimumBalanceForRentExemption(slabSize),
        newAccountPubkey: asks.publicKey,
        programId,
        space: slabSize,
    });
    signers.push(asks);
    txInstructions.push(createAsksAccount);
    // Market account
    const market = new web3_js_1.Keypair();
    const createMarketAccount = web3_js_1.SystemProgram.createAccount({
        fromPubkey: feePayer,
        lamports: await connection.getMinimumBalanceForRentExemption(market_state_1.MarketState.LEN),
        newAccountPubkey: market.publicKey,
        programId,
        space: market_state_1.MarketState.LEN,
    });
    signers.push(market);
    txInstructions.push(createMarketAccount);
    // Create market
    const createMarket = new raw_instructions_1.createMarketInstruction({
        callerAuthority: callerAuthority.toBuffer(),
        callbackInfoLen,
        callbackIdLen,
        minBaseOrderSize,
        tickSize,
        crankerReward,
    }).getInstruction(programId, market.publicKey, eventQueue.publicKey, bids.publicKey, asks.publicKey);
    txInstructions.push(createMarket);
    return [signers, txInstructions];
};
exports.createMarket = createMarket;
//# sourceMappingURL=bindings.js.map