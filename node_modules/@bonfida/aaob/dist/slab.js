"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Slab = exports.SlabHeader = exports.parseNode = exports.FreeNode = exports.LeafNode = exports.InnerNode = void 0;
const web3_js_1 = require("@solana/web3.js");
const borsh_1 = require("borsh");
const bn_js_1 = __importDefault(require("bn.js"));
// Uncomment to use WebAssembly for OB deserialization
// import { find_max, find_min, find_l2_depth } from "dex-wasm";
///////////////////////////////////////////////
////// Nodes and Slab
///////////////////////////////////////////////
class InnerNode {
    constructor(arg) {
        this.prefixLen = arg.prefixLen;
        this.key = arg.key;
        this.children = arg.children;
    }
}
exports.InnerNode = InnerNode;
InnerNode.schema = new Map([
    [
        InnerNode,
        {
            kind: "struct",
            fields: [
                ["prefixLen", "u64"],
                ["key", "u128"],
                ["children", ["u32", 2]],
            ],
        },
    ],
]);
class LeafNode {
    constructor(arg) {
        this.key = arg.key;
        this.callBackInfoPt = arg.callBackInfoPt;
        this.baseQuantity = arg.baseQuantity;
    }
    /**
     * @return the price of this order
     */
    getPrice() {
        return this.key.shrn(64);
    }
}
exports.LeafNode = LeafNode;
LeafNode.schema = new Map([
    [
        LeafNode,
        {
            kind: "struct",
            fields: [
                ["key", "u128"],
                ["callBackInfoPt", "u64"],
                ["baseQuantity", "u64"],
            ],
        },
    ],
]);
class FreeNode {
    constructor(arg) {
        this.next = arg.next;
    }
}
exports.FreeNode = FreeNode;
FreeNode.schema = new Map([
    [
        FreeNode,
        {
            kind: "struct",
            fields: [["next", "u32"]],
        },
    ],
]);
/**
 * Deserializes a node buffer
 * @param data Buffer to deserialize
 * @returns Returns a node
 */
function parseNode(data) {
    switch (data[0]) {
        case 0:
            throw new Error("node is unitialized");
        case 1:
            return borsh_1.deserializeUnchecked(InnerNode.schema, InnerNode, data.slice(Slab.NODE_TAG_SIZE));
        case 2:
            return borsh_1.deserializeUnchecked(LeafNode.schema, LeafNode, data.slice(Slab.NODE_TAG_SIZE));
        case 3:
            return borsh_1.deserializeUnchecked(FreeNode.schema, FreeNode, data.slice(Slab.NODE_TAG_SIZE));
        case 4:
            return borsh_1.deserializeUnchecked(FreeNode.schema, FreeNode, data.slice(Slab.NODE_TAG_SIZE));
        default:
            throw new Error("Invalid data");
    }
}
exports.parseNode = parseNode;
class SlabHeader {
    constructor(arg) {
        this.accountTag = arg.accountTag;
        this.bumpIndex = arg.bumpIndex;
        this.freeListLen = arg.freeListLen;
        this.freeListHead = arg.freeListHead;
        this.callbackMemoryOffset = arg.callbackMemoryOffset;
        this.callbackFreeListLen = arg.callbackFreeListLen;
        this.callbackFreeListHead = arg.callbackFreeListHead;
        this.callbackBumpIndex = arg.callbackBumpIndex;
        this.rootNode = arg.rootNode;
        this.leafCount = arg.leafCount;
        this.marketAddress = new web3_js_1.PublicKey(arg.marketAddress);
    }
}
exports.SlabHeader = SlabHeader;
SlabHeader.LEN = 97;
SlabHeader.PADDED_LEN = SlabHeader.LEN + 7;
SlabHeader.schema = new Map([
    [
        SlabHeader,
        {
            kind: "struct",
            fields: [
                ["accountTag", "u8"],
                ["bumpIndex", "u64"],
                ["freeListLen", "u64"],
                ["freeListHead", "u32"],
                ["callbackMemoryOffset", "u64"],
                ["callbackFreeListLen", "u64"],
                ["callbackFreeListHead", "u64"],
                ["callbackBumpIndex", "u64"],
                ["rootNode", "u32"],
                ["leafCount", "u64"],
                ["marketAddress", [32]],
            ],
        },
    ],
]);
class Slab {
    constructor(arg) {
        this.header = arg.header;
        this.buffer = arg.buffer;
        this.callBackInfoLen = arg.callBackInfoLen;
        const capacity = new bn_js_1.default(this.buffer.length - SlabHeader.PADDED_LEN);
        const size = this.callBackInfoLen.addn(Slab.SLOT_SIZE * 2);
        this.orderCapacity = Math.floor(capacity.div(size).toNumber());
        this.callbackMemoryOffset = new bn_js_1.default(this.orderCapacity)
            .muln(2 * Slab.SLOT_SIZE)
            .addn(SlabHeader.PADDED_LEN);
    }
    static deserialize(data, callBackInfoLen) {
        return new Slab({
            header: borsh_1.deserializeUnchecked(SlabHeader.schema, SlabHeader, data),
            buffer: data,
            callBackInfoLen,
        });
    }
    /**
     * Returns a node by its key
     * @param key Key of the node to fetch
     * @returns A node LeafNode object
     */
    getNodeByKey(key) {
        let pointer = this.header.rootNode;
        while (true) {
            const offset = SlabHeader.PADDED_LEN + pointer * Slab.SLOT_SIZE;
            let node = parseNode(this.buffer.slice(offset, offset + Slab.SLOT_SIZE));
            if (node instanceof InnerNode) {
                const critBitMaks = (1 << 127) >> node.prefixLen.toNumber();
                let critBit = key & critBitMaks;
                pointer = node.children[critBit];
            }
            if (node instanceof LeafNode) {
                return node;
            }
        }
    }
    // Uncomment if you are using webassembly
    // /**
    //  * Return min or max node of the critbit tree
    //  * @param max Boolean (false for best asks and true for best bids)
    //  * @returns Returns the min or max node of the Slab
    //  */
    // getMinMax(max: boolean) {
    //   let pointer;
    //   if (max) {
    //     pointer = find_max(
    //       this.data,
    //       BigInt(this.callBackInfoLen),
    //       BigInt(this.slotSize)
    //     );
    //   } else {
    //     pointer = find_min(
    //       this.data,
    //       BigInt(this.callBackInfoLen),
    //       BigInt(this.slotSize)
    //     );
    //   }
    //   let offset = SlabHeader.LEN;
    //   if (!pointer) {
    //     throw new Error("Empty slab");
    //   }
    //   let node = parseNode(
    //     this.callBackInfoLen,
    //     this.data.slice(
    //       offset + pointer * this.slotSize,
    //       offset + (pointer + 1) * this.slotSize
    //     )
    //   );
    //   return node;
    // }
    /**
     * Walkdown the critbit tree
     * @param descending
     * @returns
     */
    *items(descending = false) {
        if (this.header.leafCount.eq(new bn_js_1.default(0))) {
            return;
        }
        const stack = [this.header.rootNode];
        while (stack.length > 0) {
            const pointer = stack.pop();
            if (pointer === undefined)
                throw new Error("unreachable!");
            let offset = SlabHeader.PADDED_LEN + pointer * Slab.SLOT_SIZE;
            const node = parseNode(this.buffer.slice(offset, offset + Slab.SLOT_SIZE));
            if (node instanceof LeafNode) {
                yield node;
            }
            else if (node instanceof InnerNode) {
                if (descending) {
                    stack.push(node.children[0], node.children[1]);
                }
                else {
                    stack.push(node.children[1], node.children[0]);
                }
            }
        }
    }
    [Symbol.iterator]() {
        return this.items(false);
    }
    // Uncomment if you are using webassembly
    // /**
    //  * Returns an array of [price, size] given a certain depth
    //  * @param depth Depth to fetch
    //  * @param max Boolean (false for asks and true for bids)
    //  * @returns Returns an array made of [price, size] elements
    //  */
    // getL2Depth(depth: number, increasing: boolean): Price[] {
    //   let raw = find_l2_depth(
    //     this.data,
    //     BigInt(this.callBackInfoLen),
    //     BigInt(this.slotSize),
    //     BigInt(depth),
    //     increasing
    //   );
    //   let result: Price[] = [];
    //   for (let i = 0; i < raw.length / 2; i++) {
    //     result.push({
    //       size: Number(raw[2 * i]),
    //       price: Number(raw[2 * i + 1]) / 2 ** 32,
    //     });
    //   }
    //   return result;
    // }
    /**
     * Returns the top maxNbOrders (not aggregated by price)
     * @param maxNbOrders
     * @param max Boolean (false for asks and true for bids)
     * @returns Returns an array of LeafNode object
     */
    getMinMaxNodes(maxNbOrders, max) {
        const minMaxOrders = [];
        for (const leafNode of this.items(max)) {
            if (minMaxOrders.length === maxNbOrders) {
                break;
            }
            minMaxOrders.push(leafNode);
        }
        return minMaxOrders;
    }
    /**
     * Aggregates price levels up to the given depth
     * @param depth maximum number of price levels
     * @param increasing true to return in increasing order
     * @returns aggregated quantities at each price level
     */
    getL2DepthJS(depth, increasing) {
        if (this.header.leafCount.eq(new bn_js_1.default(0))) {
            return [];
        }
        let raw = [];
        let stack = [this.header.rootNode];
        while (true) {
            const current = stack.pop();
            if (current === undefined)
                break;
            let offset = SlabHeader.PADDED_LEN + current * Slab.SLOT_SIZE;
            const node = parseNode(this.buffer.slice(offset, offset + Slab.SLOT_SIZE));
            if (node instanceof LeafNode) {
                const leafPrice = node.getPrice();
                if (raw[raw.length - 1] === leafPrice.toNumber()) {
                    const idx = raw.length - 2;
                    raw[idx] += node.baseQuantity.toNumber();
                }
                else if (raw.length === 2 * depth) {
                    // The price has changed and we have enough prices. Note that the
                    // above branch will be hit even if we already have `depth` prices
                    // so that we will finish accumulating the current level. For example,
                    // if we request one level and there are two order at the best price,
                    // we will accumulate both orders.
                    break;
                }
                else {
                    raw.push(node.baseQuantity.toNumber());
                    raw.push(leafPrice.toNumber());
                }
            }
            if (node instanceof InnerNode) {
                stack.push(node.children[increasing ? 1 : 0]);
                stack.push(node.children[increasing ? 0 : 1]);
            }
        }
        let result = [];
        for (let i = 0; i < raw.length / 2; i++) {
            result.push({
                size: Number(raw[2 * i]),
                price: Number(raw[2 * i + 1]),
            });
        }
        return result;
    }
    /**
     * @param callBackInfoPt a leaf node's callBackInfoPt that gives the offset to
     * the info in the appropriate Slab.
     * @returns the raw binary callback info for the node
     */
    getCallBackInfo(callBackInfoPt) {
        return this.buffer.slice(callBackInfoPt.toNumber(), callBackInfoPt.add(this.callBackInfoLen).toNumber());
    }
}
exports.Slab = Slab;
Slab.NODE_SIZE = 32;
Slab.NODE_TAG_SIZE = 8;
Slab.SLOT_SIZE = Slab.NODE_TAG_SIZE + Slab.NODE_SIZE;
//# sourceMappingURL=slab.js.map