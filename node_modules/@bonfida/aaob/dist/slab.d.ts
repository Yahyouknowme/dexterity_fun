/// <reference types="node" />
import { PublicKey } from "@solana/web3.js";
import { Schema } from "borsh";
import BN from "bn.js";
import { AccountTag } from "./market_state";
import { Price } from "./types";
export declare class InnerNode {
    prefixLen: BN;
    key: BN;
    children: number[];
    static schema: Schema;
    constructor(arg: {
        prefixLen: BN;
        key: BN;
        children: number[];
    });
}
export declare class LeafNode {
    key: BN;
    callBackInfoPt: BN;
    baseQuantity: BN;
    static schema: Schema;
    constructor(arg: {
        key: BN;
        callBackInfoPt: BN;
        baseQuantity: BN;
    });
    /**
     * @return the price of this order
     */
    getPrice(): BN;
}
export declare class FreeNode {
    next: number;
    static schema: Schema;
    constructor(arg: {
        next: number;
    });
}
/**
 * Deserializes a node buffer
 * @param data Buffer to deserialize
 * @returns Returns a node
 */
export declare function parseNode(data: Buffer): undefined | FreeNode | LeafNode | InnerNode;
export declare class SlabHeader {
    accountTag: AccountTag;
    bumpIndex: BN;
    freeListLen: BN;
    freeListHead: number;
    callbackMemoryOffset: BN;
    callbackFreeListLen: BN;
    callbackFreeListHead: BN;
    callbackBumpIndex: BN;
    rootNode: number;
    leafCount: BN;
    marketAddress: PublicKey;
    static LEN: number;
    static PADDED_LEN: number;
    static schema: Schema;
    constructor(arg: {
        accountTag: number;
        bumpIndex: BN;
        freeListLen: BN;
        freeListHead: number;
        callbackMemoryOffset: BN;
        callbackFreeListLen: BN;
        callbackFreeListHead: BN;
        callbackBumpIndex: BN;
        rootNode: number;
        leafCount: BN;
        marketAddress: Uint8Array;
    });
}
export declare class Slab {
    header: SlabHeader;
    buffer: Buffer;
    callBackInfoLen: BN;
    orderCapacity: number;
    callbackMemoryOffset: BN;
    static NODE_SIZE: number;
    static NODE_TAG_SIZE: number;
    static SLOT_SIZE: number;
    constructor(arg: {
        header: SlabHeader;
        buffer: Buffer;
        callBackInfoLen: BN;
    });
    static deserialize(data: Buffer, callBackInfoLen: BN): Slab;
    /**
     * Returns a node by its key
     * @param key Key of the node to fetch
     * @returns A node LeafNode object
     */
    getNodeByKey(key: number): LeafNode;
    /**
     * Walkdown the critbit tree
     * @param descending
     * @returns
     */
    items(descending?: boolean): Generator<LeafNode>;
    [Symbol.iterator](): Generator<LeafNode, any, unknown>;
    /**
     * Returns the top maxNbOrders (not aggregated by price)
     * @param maxNbOrders
     * @param max Boolean (false for asks and true for bids)
     * @returns Returns an array of LeafNode object
     */
    getMinMaxNodes(maxNbOrders: number, max: boolean): LeafNode[];
    /**
     * Aggregates price levels up to the given depth
     * @param depth maximum number of price levels
     * @param increasing true to return in increasing order
     * @returns aggregated quantities at each price level
     */
    getL2DepthJS(depth: number, increasing: boolean): Price[];
    /**
     * @param callBackInfoPt a leaf node's callBackInfoPt that gives the offset to
     * the info in the appropriate Slab.
     * @returns the raw binary callback info for the node
     */
    getCallBackInfo(callBackInfoPt: BN): Buffer;
}
