"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.closeMarketInstruction = exports.createMarketInstruction = exports.consumeEventsInstruction = exports.newOrderInstruction = exports.cancelOrderInstruction = void 0;
const borsh_1 = require("borsh");
const web3_js_1 = require("@solana/web3.js");
class cancelOrderInstruction {
    constructor(obj) {
        this.tag = 3;
        this.orderId = obj.orderId;
    }
    serialize() {
        return borsh_1.serialize(cancelOrderInstruction.schema, this);
    }
    getInstruction(programId, market, eventQueue, bids, asks, authority) {
        const data = Buffer.from(this.serialize());
        let keys = [];
        keys.push({
            pubkey: market,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: eventQueue,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: bids,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: asks,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: authority,
            isSigner: true,
            isWritable: false,
        });
        return new web3_js_1.TransactionInstruction({
            keys,
            programId,
            data,
        });
    }
}
exports.cancelOrderInstruction = cancelOrderInstruction;
cancelOrderInstruction.schema = new Map([
    [
        cancelOrderInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["orderId", "u128"],
            ],
        },
    ],
]);
class newOrderInstruction {
    constructor(obj) {
        this.tag = 1;
        this.maxBaseQty = obj.maxBaseQty;
        this.maxQuoteQty = obj.maxQuoteQty;
        this.limitPrice = obj.limitPrice;
        this.side = obj.side;
        this.matchLimit = obj.matchLimit;
        this.callbackInfo = obj.callbackInfo;
        this.postOnly = obj.postOnly;
        this.postAllowed = obj.postAllowed;
        this.selfTradeBehavior = obj.selfTradeBehavior;
    }
    serialize() {
        return borsh_1.serialize(newOrderInstruction.schema, this);
    }
    getInstruction(programId, market, eventQueue, bids, asks, authority) {
        const data = Buffer.from(this.serialize());
        let keys = [];
        keys.push({
            pubkey: market,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: eventQueue,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: bids,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: asks,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: authority,
            isSigner: true,
            isWritable: false,
        });
        return new web3_js_1.TransactionInstruction({
            keys,
            programId,
            data,
        });
    }
}
exports.newOrderInstruction = newOrderInstruction;
newOrderInstruction.schema = new Map([
    [
        newOrderInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["maxBaseQty", "u64"],
                ["maxQuoteQty", "u64"],
                ["limitPrice", "u64"],
                ["side", "u8"],
                ["matchLimit", "u64"],
                ["callbackInfo", "u8"],
                ["postOnly", "u8"],
                ["postAllowed", "u8"],
                ["selfTradeBehavior", "u8"],
            ],
        },
    ],
]);
class consumeEventsInstruction {
    constructor(obj) {
        this.tag = 2;
        this.numberOfEntriesToConsume = obj.numberOfEntriesToConsume;
    }
    serialize() {
        return borsh_1.serialize(consumeEventsInstruction.schema, this);
    }
    getInstruction(programId, market, eventQueue, authority, rewardTarget) {
        const data = Buffer.from(this.serialize());
        let keys = [];
        keys.push({
            pubkey: market,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: eventQueue,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: authority,
            isSigner: true,
            isWritable: false,
        });
        keys.push({
            pubkey: rewardTarget,
            isSigner: false,
            isWritable: true,
        });
        return new web3_js_1.TransactionInstruction({
            keys,
            programId,
            data,
        });
    }
}
exports.consumeEventsInstruction = consumeEventsInstruction;
consumeEventsInstruction.schema = new Map([
    [
        consumeEventsInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["numberOfEntriesToConsume", "u64"],
            ],
        },
    ],
]);
class createMarketInstruction {
    constructor(obj) {
        this.tag = 0;
        this.callerAuthority = obj.callerAuthority;
        this.callbackInfoLen = obj.callbackInfoLen;
        this.callbackIdLen = obj.callbackIdLen;
        this.minBaseOrderSize = obj.minBaseOrderSize;
        this.tickSize = obj.tickSize;
        this.crankerReward = obj.crankerReward;
    }
    serialize() {
        return borsh_1.serialize(createMarketInstruction.schema, this);
    }
    getInstruction(programId, market, eventQueue, bids, asks) {
        const data = Buffer.from(this.serialize());
        let keys = [];
        keys.push({
            pubkey: market,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: eventQueue,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: bids,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: asks,
            isSigner: false,
            isWritable: true,
        });
        return new web3_js_1.TransactionInstruction({
            keys,
            programId,
            data,
        });
    }
}
exports.createMarketInstruction = createMarketInstruction;
createMarketInstruction.schema = new Map([
    [
        createMarketInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["callerAuthority", [32]],
                ["callbackInfoLen", "u64"],
                ["callbackIdLen", "u64"],
                ["minBaseOrderSize", "u64"],
                ["tickSize", "u64"],
                ["crankerReward", "u64"],
            ],
        },
    ],
]);
class closeMarketInstruction {
    constructor() {
        this.tag = 4;
    }
    serialize() {
        return borsh_1.serialize(closeMarketInstruction.schema, this);
    }
    getInstruction(programId, market, eventQueue, bids, asks, authority, lamportsTargetAccount) {
        const data = Buffer.from(this.serialize());
        let keys = [];
        keys.push({
            pubkey: market,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: eventQueue,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: bids,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: asks,
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: authority,
            isSigner: true,
            isWritable: false,
        });
        keys.push({
            pubkey: lamportsTargetAccount,
            isSigner: false,
            isWritable: true,
        });
        return new web3_js_1.TransactionInstruction({
            keys,
            programId,
            data,
        });
    }
}
exports.closeMarketInstruction = closeMarketInstruction;
closeMarketInstruction.schema = new Map([
    [
        closeMarketInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
            ],
        },
    ],
]);
//# sourceMappingURL=raw_instructions.js.map